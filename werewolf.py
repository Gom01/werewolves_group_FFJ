import os

import openai
from pydantic import BaseModel
from abc import ABC, abstractmethod
from typing import List
import random
import re

# Initialise un client
import openai
from api_key import OPENAI_API_KEY

client = openai.OpenAI(api_key=OPENAI_API_KEY)


class Intent(BaseModel):
    want_to_speak:bool = False
    want_to_interrupt:bool = False
    vote_for:str = None


class WerewolfPlayerInterface(ABC):

    @classmethod
    def create(cls, name: str, role: str, players_names: List[str], werewolves_count: int, werewolves: List[str]) -> 'WerewolfPlayerInterface':
        return cls(name, role, players_names, werewolves_count, werewolves)

    @abstractmethod
    def speak(self) -> str:
        """Generate a response when it's the player's turn to speak."""
        pass

    @abstractmethod
    def notify(self, message: str) -> Intent:
        """Process a notification and determine the player's intent."""
        pass




class WerewolfPlayer(WerewolfPlayerInterface):
    rules = """"
       Bienvenue dans LLMs-Garous, une version adapt√©e du jeu "Les Loups-Garous de Thiercelieux".
    
       üéØ Objectif :
       - Il y a 7 joueurs : 2 loups-garous, 1 voyante, 4 villageois.
       - Les loups-garous doivent √©liminer tous les villageois et la voyante.
       - Les villageois et la voyante doivent identifier et √©liminer les loups-garous.
    
       üïì D√©roulement d‚Äôun tour :
       Le jeu alterne entre deux phases : la nuit et le jour.
    
       üåô Phase de nuit :
       - Le meneur annonce "C'est la nuit, tout le village s'endort, les joueurs ferment les yeux."
       - Les loups-garous se r√©veillent, se reconnaissent et votent pour une victime.
       - La voyante se r√©veille et peut sonder un joueur pour conna√Ætre son r√¥le.
       - Les villageois dorment et ne font rien.
    
       üåû Phase de jour :
       - Le meneur annonce le r√©sultat de la nuit : s‚Äôil y a une victime et son r√¥le.
       - Les joueurs prennent la parole, s‚Äôaccusent, d√©fendent ou se taisent.
       - Chaque joueur peut :
           - demander √† parler
           - interrompre quelqu‚Äôun (max 2 fois par partie, peut √™tre refus√© par le meneur)
           - voter pendant la phase de vote
       - Apr√®s les discussions, un vote a lieu. Le joueur ayant le plus de votes est √©limin√© (en cas d‚Äô√©galit√© : personne n‚Äôest √©limin√©).
       - Le r√¥le du joueur √©limin√© est r√©v√©l√©.
    
       üó£Ô∏è Gestion de la parole :
       - Le meneur accorde la parole √† ceux qui la demandent.
       - Les joueurs silencieux depuis plusieurs tours ont plus de chances d‚Äô√™tre s√©lectionn√©s.
       - Un m√™me joueur ne peut pas parler deux fois de suite.
    
       Ton but en tant que joueur est de survivre le plus longtemps possible... ou de faire gagner ton camp.
       """

    def __init__(self, name: str, role: str, players_names: List[str], werewolves_count: int, werewolves: List[str]) -> None:
        self.name = name
        print(f"WerewolfPlayer {self.name} created")

        beginning_prompt = (""
                            f"Ton role est : {role}"
                            f"Les noms des joueurs sont : {players_names}"
                            f"Il y a {werewolves_count} loup-garou dans cette partie"
                            f"Si ton role est loup-garou les autres loup-garous sont : {werewolves}")

        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "user", "content": beginning_prompt}
            ])

        self.messages = []
        self.playerRest = players_names


    def speak(self) -> str:
        """
        Appel√© par le meneur pour donner la parole √† un joueur.
        Le joueur doit alors prendre la parole dans le jeu. 
    
        Args:
            Aucun param√®tre n'est pass√©; c'est au joueur de d√©duire le contexte uniquement depuis ce qu'il a re√ßu pr√©c√©demment via notify().
        
        Returns:
            speech: Un message contenant le texte que le joueur dit, par exemple "Je crois que Aline ment car ..."
            Un joueur peut d√©cider de ne pas parler (retourner un `speech` vide)
            
        """
        print(f"{self.name} is given the floor")
        messages_with_index = "\n".join(f"[{i}] {line}" for i, line in enumerate(self.messages))
        players_str = ", ".join(self.players_names)
        wolves_str = ", ".join(self.werewolves)

        PROMPT = f"""
        CONTEXTE :\n
        Voici notre jeu et ses r√®gles : {rules}.\n
        Tu es un joueur de ce jeu.\n
        Voici ton nom : {self.name}.\n
        Voici ton r√¥le : {self.role}.\n
        Voici les noms des autres joueurs au d√©but de la partie : {players_str}.\n
        Voici le nombre de loups au d√©but de la partie : {self.werewolves_count}.\n
        Si tu as le r√¥le de "loup-garou" , voici la liste des autres : {wolves_str}.\n
        Voici l'historique des messages depuis le d√©but du Jeu :\n
        {messages_with_index}\n
        
        TA TACHE :\n
        Tu dois soit r√©pondre ou ne pas r√©pondre. Tu as 5 secondes au maximum, pour r√©fl√©chir et r√©pondre. 
        Ton objectif est de c
    
        """

        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "user", "content": PROMPT}
            ])
        # TODO implement me
        return ""


    def notify(self, message: str) -> Intent:
        """
        Appel√© par le meneur pour deux objectifs principaux:
    
        1. Informer le joueur sur l'√©tat du jeu:
           - Qui a parl√© et ce qui a √©t√© dit
           - Si c'est la nuit
           - Les rumeurs
           - Si c'est le moment de voter
           - Le r√©sultat du vote (qui a √©t√© √©limin√© et son r√¥le)
           - Autres informations pertinentes sur l'√©tat du jeu
    
        Le message est **sous forme de texte uniquement** et c'est au joueur de l'interpr√©ter en fonction du contexte.
        Le message contient uniquement le dernier (nouveau) message du meneur, c'est au joueur de m√©moriser les informations des messages pr√©c√©dents.
        
        2. Recevoir en retour les intentions du joueur:
           - Demande de prise de parole
           - Demande d'interruption
           - Vote
    
        La r√©ponse suivra **strictement le sch√©ma** ci-dessous, sans quoi elle sera ignor√©e par le meneur.
        
        Args:
            message: "C'est le matin, le village se r√©veille. Aline a √©t√© tu√©e cette nuit. Aline √©tait une villageoise."
        
        Returns:
            Une Intent (voir la classe ci-dessus l. 8) contenant les actions du joueur. Sch√©ma:
                want_to_speak: True | False,
                want_to_interrupt: True | False,
                vote_for: "Aline" | "Benjamin" | ... | None

        """
        print(f"{self.name} received message: {message}")
        # TODO implement me

        self.messages.append("[Meneur de jeu] " + message)


        # donne le nom de la personne la plus suspect dans la liste
        PROMPT = f"""
        
        Par rapport au message, voici toutes les actions possible. Il est possible d'en faire plusieurs √† la fois.
        
        1) Si un joueur est mort, dit son nom.
        EXEMPLE : 
            Meneur de jeu : "Aline est mort"
            Toi : "mort:Aline"
            
        2) Si c'est le moment de voter, donne un nom al√©atoire dans la liste {self.playerRest}.
        Tu ne peux pas voter pour toi-m√™me.
        EXEMPLE : 
            Meneur de jeu : "Il est temps de voter"
            Toi : "vote:David"
            
        3) Si c'est le r√©sultat du vote, donne le nom de la victime et son r√¥le.
        EXEMPLE:
            Meneur du jeu : "Ainsi, Fr√©d√©ric est mort et son r√¥le √©tait villageois"
        
        """

        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "user", "content": PROMPT }
            ]).choices[0].message.content

        if "mort" in response:
            self.playerRest.remove(response.split(":")[1])

        self.messages.append(f"[{self.name}] " + response)

        return Intent(want_to_speak=False, want_to_interrupt=False, vote_for="")
